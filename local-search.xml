<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何使用Rest Assured进行RESTful API测试</title>
    <link href="/shinyruotechtips/2024/02/bba85c2d0992/"/>
    <url>/shinyruotechtips/2024/02/bba85c2d0992/</url>
    
    <content type="html"><![CDATA[<h4 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h4><p>随着互联网和移动设备的发展，人们对Web应用的使用需求也增加，传统的动态页面（如JSP）由于低效率而渐渐被HTML+JavaScript(Ajax)的前后端分离所取代，并且安卓、IOS、小程序等形式客户端层出不穷，客户端的种类出现多元化，而客户端和服务端就需要接口进行通信，但接口的规范性是一个问题。</p><p>所以一套结构清晰、符合标准、易于理解、扩展方便让大部分人都能够理解接受的接口风格就显得越来越重要，而RESTful风格的接口(RESTful API)刚好有以上特点，就逐渐被实践应用而变得流行起来，可以参考<a href="https://docs.github.com/en/rest?apiVersion=2022-11-28">GitHub REST API documentation - GitHub Docs</a>的文档对REST API进行学习。</p><p>REST并没有一个明确的标准，而更像是一种设计的风格，满足这种设计风格的程序或接口我们称之为RESTful（从单词字面来看就是一个形容词）。所以RESTful API 就是满足REST架构风格的接口。如果用一句话大概概括一下REST风格，那就是<strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong> 此处只简单介绍REST API，因为这不是讨论的重点，关于REST API设计规范和限制条件，需要在日常开发中了解学习。</p><h4 id="HTTP请求方法和状态码"><a href="#HTTP请求方法和状态码" class="headerlink" title="HTTP请求方法和状态码"></a>HTTP请求方法和状态码</h4><p>REST API使用五种HTTP方法来发送请求：</p><ul><li>GET：在特定的URL上检索信息。</li><li>PUT：如果资源存在，则更新先前的资源，若不存在，则创建新的信息。</li><li>POST：向服务器发送信息，例如上传数据或创建新的实体。</li><li>DELETE：删除特定URL上的所有当前资源。</li><li>PATCH：用于对资源进行部分更新。</li></ul><p>当使用以上方法发送请求后，客户端会收到数字形式的代码，称为“状态码”，有时也叫“响应码”。然后我们可以根据这些状态码来解读服务器对特定请求发送的响应。状态码主要分为五类，具体如下：</p><ul><li>1xx（100-199）：信息，服务器收到请求，需要请求者继续执行操作</li><li>2xx（200-299）：成功，操作被成功接收并处理</li><li>3xx（300-399）：重定向，需要进一步的操作以完成请求</li><li>4xx（400-499）：客户端错误，请求包含语法错误或无法完成请求</li><li>5xx（500-599）：服务器错误，服务器在处理请求的过程中发生了错误，无法完成请求</li></ul><p>通过以上状态码，我们可以判断应用程序的运行情况。1xx、2xx和3xx状态码通常不被视为错误，而是提供了一些信息性的消息，它们并不会影响用户体验。</p><p>但是，如果收到了4xx或5xx状态码，则表示发生了错误。这意味着用户&#x2F;APP在访问API时可能会遇到错误消息。4xx状态码通常与客户端或浏览器级别的错误相关，而5xx状态码通常表示服务器级别的错误。因此在进行REST API测试时，应该通过检查这些错误代码来评估每个响应的情况。</p><p>有关HTTP协议的具体内容细节，可以查阅。<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以toolsqa网站的一个demo作为例子，我们可以在这里<a href="https://demoqa.com/swagger/#/BookStore">Swagger UI (demoqa.com)</a>看到该示例提供的一些API，这个例子是一个书店的库存管理系统，提供了多种REST API方法来获取书店中书的信息。</p><p>Swagger 是一个实现了OpenAPI 规范的工具集，SwaggerUI是其生成的文档&#x2F;页面。</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-21-17-54-42-image.png"></p><p>在SwaggerUI中我们还可以对接口进行执行，这里的GET方法返回的是Books的具体内容。</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-21-17-56-19-image.png"></p><h4 id="使用Rest-Assured进行REST-API测试"><a href="#使用Rest-Assured进行REST-API测试" class="headerlink" title="使用Rest Assured进行REST API测试"></a>使用Rest Assured进行REST API测试</h4><p>Rest Assured是一个Java库，用于测试RESTful API。它被广泛应用于测试基于JSON和XML的Web应用程序。此外，它完全支持GET、PUT、POST、PATCH和DELETE等所有REST方法。接下来详细介绍如何使用Rest Assured库测试一个REST API。</p><p>要编写一个示例的REST API测试，我们将使用以下REST API链接。</p><ul><li><p>请求URL：<a href="https://demoqa.com/BookStore/v1/Books">https://demoqa.com/BookStore/v1/Books</a></p></li><li><p>HTTP方法：GET</p></li><li><p>备注：此URL将返回书店的库存详情。请求中没有输入参数。</p></li><li><p>响应：{“books”: [{“isbn”: “string”,”title”: “string”,”subTitle”: “string”,”author”:”string”,”publish_date”: “2022-01-25T13:44:50.276Z”,”publisher”: “string”,”pages”: 0,”description”: “string”,”website”: “string”}]}</p></li></ul><p>实际上，如果我们直接在浏览器中打开上述URL，我们会得到如下所示的输出：</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-26-15-37-48-image.png"></p><p>要使用Rest Assured库以编程方式获取相同的输出，我们需要按照以下步骤操作：</p><ol><li>使用RestAssured类生成一个针对URL的RequestSpecification。</li><li>指定HTTP方法类型（GET方法）。</li><li>将请求发送到服务器。</li><li>从服务器获取响应。</li><li>打印返回的响应体。</li></ol><p>以下是执行以上步骤的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.restassured.RestAssured;<br><span class="hljs-keyword">import</span> io.restassured.http.Method;<br><span class="hljs-keyword">import</span> io.restassured.response.Response;<br><span class="hljs-keyword">import</span> io.restassured.specification.RequestSpecification;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestAssuredAPITest</span> &#123;<br><br> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetBooksDetails</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-comment">// Specify the base URL to the RESTful web service </span><br>    RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>; <br>    <span class="hljs-comment">// Get the RequestSpecification of the request to be sent to the server. </span><br>    <span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given(); <br>    <span class="hljs-comment">// specify the method type (GET) and the parameters if any. </span><br>    <span class="hljs-comment">//In this case the request does not take any parameters </span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.request(Method.GET, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// Print the status and message body of the response received from the server </span><br>    System.out.println(<span class="hljs-string">&quot;Status received =&gt; &quot;</span> + response.getStatusLine()); <br>    System.out.println(<span class="hljs-string">&quot;Response=&gt;&quot;</span> + response.prettyPrint());<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，我们就能够发起测试 API 调用，并从对应的接口获取响应了。</p><p>现在我们来简单说明一下对应的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定 RESTful Web 服务的基本 URL</span><br>RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>;<br></code></pre></td></tr></table></figure><p>上述代码使用 RestAssured 类来设定基本 URI。在这里，基本 URI 是 “<a href="https://demoqa.com/BookStore/v1/Books%E2%80%9D%E3%80%82%E5%9F%BA%E6%9C%AC">https://demoqa.com/BookStore/v1/Books”。基本</a> URI 指示了我们即将从服务器请求的资源的根地址（因此称为基本 URI）。然后，当我们在随后的代码中实际发起请求时，我们会添加参数（如果有的话）。</p><p>io.restassured.RestAssured 类是我们进行测试时所发起的任何类型的 HTTP 请求的基础。该类的一些关键特性包括：</p><ul><li>使用基本 URI 生成 HTTP 请求。</li><li>提供支持以创建不同的 HTTP 方法类型（GET、POST、PUT、PATCH、DELETE、UPDATE、HEAD 和 OPTIONS）的请求。</li><li>使用 HTTP 与服务器进行通信，并将测试中创建的请求发送到服务器。</li><li>接收来自服务器的响应。</li><li>提供支持验证从服务器接收到的响应。</li><li>io.restassured.RestAssured类内部使用了一个基于 Groovy 语言的 HTTP 客户端 HTTP builder 库。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取要发送到服务器的请求的RequestSpecification</span><br><span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given(); <br><span class="hljs-comment">// 指定方法类型(GET)和参数(如果有的话)。</span><br><span class="hljs-comment">// 在这种情况下，请求不带任何参数。</span><br><span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.request(Method.GET, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>接下来的代码获取了要发送到服务器的请求的RequestSpecification对象。Rest Assured库提供了名为RequestSpecification的接口，用于此目的。变量httpRequest存储了请求，以便我们可以在需要时修改它，比如添加身份验证信息、添加头部等。在这个示例测试中，我们没有对该变量进行修改。</p><p>现在，我们调用接口以获取资源，以上代码使用request方法向服务器发送资源请求。</p><p>request方法接受两个参数，第一个是HTTP方法，第二个是一个字符串。字符串参数用于指定要与基本URI一起发送的参数。在这种情况下，为了获取Books的详情，我们不发送任何参数，因此使用了空字符串。request方法的返回类型是Response对象，这意味着request方法从服务器获取了响应并且把结果存在response这个实例中。</p><p>Response接口（io.restassured.response.Response）表示从服务器返回的响应。它包含服务器发送的所有数据。接下来的例子中可以调用此响应对象上的不同方法来提取响应，例如响应状态、header等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 打印从服务器接收到的响应消息正文</span><br>System.out.println(<span class="hljs-string">&quot;Status received =&gt; &quot;</span> + response.getStatusLine());<br>System.out.println(<span class="hljs-string">&quot;Response=&gt;&quot;</span> + response.prettyPrint());<br></code></pre></td></tr></table></figure><p>在上述代码行中，我们将响应作为字符串读取，并将其打印到System.out。我们使用响应接口的getBody方法返回响应的body。然后将其打印到System.out。</p><p>我们也可以使用Rest Assured提供的简写方法来编写上述测试代码。以下是稍微简化了的代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetWeatherDetailsCondensed</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 指定RESTful web服务的基本URL</span><br>RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>;<br><span class="hljs-comment">// 获取要发送的请求的RequestSpecification</span><br><span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given();<br><span class="hljs-comment">// 调用RequestSpecification.get()方法以获取响应。</span><br><span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.get(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// Response.asString方法将直接返回主体的内容 // 作为字符串</span><br>System.out.println(<span class="hljs-string">&quot;Response Body is =&gt; &quot;</span> + response.asString());<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里使用了RequestSpecification对象上的“get”方法，该方法向接口发送了一个GET方法，返回Response对象。</p><h4 id="使用Rest-Assured验证HTTP响应状态"><a href="#使用Rest-Assured验证HTTP响应状态" class="headerlink" title="使用Rest Assured验证HTTP响应状态"></a>使用Rest Assured验证HTTP响应状态</h4><p>每个客户端发送到服务器的HTTP请求都会收到一个HTTP响应，其中包含一个状态码。这个状态码告诉我们HTTP响应是否成功。其中我们进行了一个示例的REST API测试调用。接下来将讨论如何使用REST Assured来验证HTTP响应的状态。</p><p>一个HTTP响应对象通常代表了Web服务服务器发回的HTTP数据包（响应数据包），作为对客户端请求的响应。一个HTTP响应包含状态、header、body这几个部分。当我们说需要验证HTTP响应状态时，我们希望有一种机制来读取和验证整个响应对象，包括状态、header、body，需要验证HTTP响应的每个组成部分。</p><p>同一个REST API会以XML或JSON格式返回响应消息，格式取决于HTTP请求中的Media-Type属性。那么客户端如何知道它将从API获得什么类型的响应呢？这是由响应头来管理的。响应头包含一个Content-Type属性，用于通知响应主体格式的类型。</p><p>假设我们通过浏览器向图书商店发送GET请求，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X GET <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span> -H <span class="hljs-string">&quot;accept: application/json&quot;</span><br></code></pre></td></tr></table></figure><p>执行上述命令，结果如下：</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-26-16-33-28-image.png"></p><p>如图，响应头中包含一个content-type属性，还有一些其他的属性值。通过解析这个头部，客户端就知道可以期待什么类型的响应（body）。</p><p>当客户端从服务器请求特定信息时，服务器会向客户端发送一个带有状态码的响应。服务器返回的状态码告诉我们请求是否成功。如果请求成功，服务器会在200-299的范围内发送状态码。如果请求未成功，则返回不在该范围内的状态码。</p><p>Rest Assured库提供了一个名为”io.restassured.response”的包，其中包含一个Response接口。Response接口提供了一些方法，可以帮助获取接收到的响应的各个部分。</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-26-16-44-56-image.png"></p><p>其中方法 getStatusCode() 用于获取响应的状态码。该方法返回一个int，然后我们可以验证其值，这里使用TestNG Assert 用于验证状态码，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><span class="hljs-keyword">import</span> org.testng.Assert;   <span class="hljs-comment">//用于验证响应状态 </span><br><span class="hljs-keyword">import</span> org.testng.annotations.Test;<br><span class="hljs-keyword">import</span> io.restassured.RestAssured;<br><span class="hljs-keyword">import</span> io.restassured.response.Response;<br><span class="hljs-keyword">import</span> io.restassured.specification.RequestSpecification;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestAssuredTestResponse</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetBookDetails</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 指定 RESTful web 服务的基本 URL</span><br>        RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>;<br>        <span class="hljs-comment">// 获取要发送到服务器的请求的 RequestSpecification</span><br>        <span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given();<br><br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.get(<span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-comment">// 获取请求的状态码。 </span><br>        <span class="hljs-comment">// 如果请求成功，状态码将是 200</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusCode();<br><br>        <span class="hljs-comment">// 断言返回正确的状态码。</span><br>        Assert.assertEquals(statusCode <span class="hljs-comment">/*实际值*/</span>, <span class="hljs-number">200</span> <span class="hljs-comment">/*期望值*/</span>, <span class="hljs-string">&quot;返回了正确的状态码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的代码用于获取状态码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusCode();<br></code></pre></td></tr></table></figure><p>返回值 “statusCode” 被与期望值即 200 进行比较。如果两个值相等，则返回相应的消息或者打印正确的log。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 断言正确的状态码已返回。</span><br>Assert.assertEquals(statusCode <span class="hljs-comment">/*实际值*/</span>, <span class="hljs-number">200</span> <span class="hljs-comment">/*期望值*/</span>, <span class="hljs-string">&quot;返回了正确的状态码&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过这种方式，我们可以使用响应接口的 “getStatusCode()” 方法来验证响应的状态码，这是一种比较常见的场景，即接口返回成功的状态码2xx。接下来让我们讨论如何验证返回值不是 200（即错误状态码）的状态码，这也是另一种对接口的常见测试场景。</p><p>在实际的测试场景中可能存在诸如服务器宕机、REST API 不正常运行或请求本身存在问题等原因。总之，我们可能会遇到以下几种情况：</p><ol><li>服务器宕机。</li><li>客户端请求不正确。</li><li>客户端请求的资源不存在。</li><li>在处理请求时服务器端发生错误。</li></ol><p>当出现以上任何情况时，REST API 将返回一个错误状态码，客户端必须根据此状态码进行相应的处理。对之前给出的Demo链接，创建另一个测试，来模拟一个错误的场景。在这里，我们将验证当输入无效参数时， Web 服务返回的 HTTP 状态码。</p><p>我们提供参数以获取用户详细信息。这里我们提供了不存在的 userId 作为参数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><span class="hljs-keyword">import</span> org.testng.Assert;   <span class="hljs-comment">//用于验证响应状态 </span><br><span class="hljs-keyword">import</span> org.testng.annotations.Test;<br><span class="hljs-keyword">import</span> io.restassured.RestAssured;<br><span class="hljs-keyword">import</span> io.restassured.response.Response;<br><span class="hljs-keyword">import</span> io.restassured.specification.RequestSpecification;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestAssuredTestResponse</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetPetDetails</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 指定 RESTful web 服务的基本 URL</span><br>        RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/Account/v1/User/&quot;</span>;<br>        <span class="hljs-comment">// 获取要发送到服务器的请求的 RequestSpecification</span><br>        <span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given();<br><br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.get(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-comment">// 获取请求的状态码。</span><br>        <span class="hljs-comment">// 如果请求失败，服务端返回的状态码将是401</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusCode();<br><br>        <span class="hljs-comment">// 断言正确的状态码已返回。</span><br>        Assert.assertEquals(statusCode <span class="hljs-comment">/*实际值*/</span>, <span class="hljs-number">401</span> <span class="hljs-comment">/*期望值*/</span>, <br>        <span class="hljs-string">&quot;返回了正确的状态码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这个测试，因为返回的状态码和预期的期望是相同的，所以测试通过。</p><p>除了对状态码进行验证，我们还可以验证完整的状态行及其中包含的其他消息，”状态行” 是 HTTP 响应中返回的第一行，由三个子字符串组成：</p><ol><li>HTTP 协议版本。</li><li>状态码。</li><li>状态码的字符串值。</li></ol><p>例如，当请求成功时，状态行将具有值 “HTTP&#x2F;1.1 200 OK”。这里，第一部分是 HTTP 协议（HTTP&#x2F;1.1）。接下来是 HTTP 状态码（200）。第三部分是状态消息（OK）。</p><p>我们可以使用响应接口的 <code>getStatusLine()</code> 方法来读取整个状态行。以下代码是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">GetBookDetails</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 指定 RESTful web 服务的基本 URL </span><br>    RestAssured.baseURI = <span class="hljs-string">&quot;https://demoqa.com/BookStore/v1/Books&quot;</span>; <br>    <span class="hljs-comment">// 获取要发送到服务器的请求的 RequestSpecification </span><br>    <span class="hljs-type">RequestSpecification</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> RestAssured.given(); <br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpRequest.get(<span class="hljs-string">&quot;&quot;</span>); <br><br>    <span class="hljs-comment">// 将响应中的状态行读取到变量 statusLine 中</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">statusLine</span> <span class="hljs-operator">=</span> response.getStatusLine();<br>    Assert.assertEquals(statusLine <span class="hljs-comment">/*实际值*/</span>, <span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span> <br>      <span class="hljs-comment">/*期望值*/</span>, <span class="hljs-string">&quot;返回了正确的状态码&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们执行了类似于对状态码的测试。我们使用 <code>getStatusLine()</code> 方法读取状态行，并将其存储在字符串值中。然后，我们将此返回值与 “HTTP&#x2F;1.1 200 OK” 进行比较，以检查状态是否成功。</p><p>对于header的检验大致和对于状态码的检验相同，不过header的检验更多用的是字符串相关的校验方法，此处不做详细说明。</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Rest%20Assured%E8%BF%9B%E8%A1%8CRESTful%20API%E6%B5%8B%E8%AF%95/2024-02-26-17-12-44-image.png"></p><p>对于body的检验比较复杂，后续根据实际场景再填充内容。</p><p>&#x2F;&#x2F;TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>API Testing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10分钟搭建pytest框架</title>
    <link href="/shinyruotechtips/2024/01/dca0c4d7d5ba/"/>
    <url>/shinyruotechtips/2024/01/dca0c4d7d5ba/</url>
    
    <content type="html"><![CDATA[<p>在搭建一个pytest Demo之前，首先安装pytest，pytest对于Python版本的要求是3.8+</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt; pip install -U pytest<br>&gt;&gt; pytest --version<br>pytest 7.4.4<br></code></pre></td></tr></table></figure><h4 id="创建第一个测试"><a href="#创建第一个测试" class="headerlink" title="创建第一个测试"></a>创建第一个测试</h4><p>创建一个包含一个函数和一个测试的<code>test_sample.py</code>文件，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_sample.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_answer</span>():<br>    <span class="hljs-keyword">assert</span> func(<span class="hljs-number">3</span>) == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt; pytest<br>=============================================== <span class="hljs-built_in">test</span> session starts ================================================<br>platform win32 -- Python 3.12.1, pytest-7.4.4, pluggy-1.4.0<br>rootdir: C:\Users\miaoh\Desktop\pytest<br>collected 1 item                                                                                                     <br><br>test_sample.py F                                                                                              [100%]<br><br>===================================================== FAILURES ===================================================== <br>___________________________________________________ test_answer ____________________________________________________ <br><br>    def test_answer():<br>&gt;       assert func(3) == 5<br>E       assert 4 == 5<br>E        +  <span class="hljs-built_in">where</span> 4 = func(3)<br><br>test_sample.py:7: AssertionError<br>============================================= short <span class="hljs-built_in">test</span> summary info ============================================== <br>FAILED test_sample.py::test_answer - assert 4 == 5<br>================================================ 1 failed <span class="hljs-keyword">in</span> 0.06s ================================================= <br></code></pre></td></tr></table></figure><p>这里的<code>[100%]</code>指的是运行的所有测试用例的进度。很明显，fun(3)返回的结果是4，这个assert失败了。</p><h4 id="运行多个测试用例"><a href="#运行多个测试用例" class="headerlink" title="运行多个测试用例"></a>运行多个测试用例</h4><p>简言之，<code>pytest</code> 会在运行该命令的当前目录和子目录中查找格式为test_*.py or *_test.py的文件并且运行，具体的查找规则参考<a href="https://docs.pytest.org/en/latest/explanation/goodpractices.html#test-discovery">standard test discovery rules</a></p><h4 id="断言一个特定的异常"><a href="#断言一个特定的异常" class="headerlink" title="断言一个特定的异常"></a>断言一个特定的异常</h4><p>参考<a href="https://docs.pytest.org/en/latest/how-to/assert.html#assertraises">raises</a>我们可以断言某个异常的发生</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_sysexit.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_mytest</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(SystemExit):<br>        f()<br></code></pre></td></tr></table></figure><p>也可以使用由raises](<a href="https://docs.pytest.org/en/latest/how-to/assert.html#assertraises">How to write and report assertions in tests &amp;#8212; pytest documentation</a>)提供的上下文来断言预期的异常是抛出的<a href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.12)"><code>ExceptionGroup</code></a>的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_exceptiongroup.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">raise</span> ExceptionGroup(<br>        <span class="hljs-string">&quot;Group message&quot;</span>,<br>        [<br>            RuntimeError(),<br>        ],<br>    )<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception_in_group</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ExceptionGroup) <span class="hljs-keyword">as</span> excinfo:<br>        f()<br>        <span class="hljs-keyword">assert</span> excinfo.group_contains(RuntimeError)<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> excinfo.group_contains(TypeError)<br></code></pre></td></tr></table></figure><p>这个case会失败，因为在目前的stable版本python中，这个Execinfo方法还什么都没有写，而<code>assert</code>需要后边是个boolean值。在GitHub pytest的issue里也可以看到有相关的issue</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">group_contains</span>(<span class="hljs-params">self, RuntimeError</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h4 id="在一个类中定义多个测试用例"><a href="#在一个类中定义多个测试用例" class="headerlink" title="在一个类中定义多个测试用例"></a>在一个类中定义多个测试用例</h4><p>当你添加多个测试用例的时候，你可能希望将它们分组到一个类中。pytest使得创建包含多个测试的类变得很容易：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_class.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_one</span>(<span class="hljs-params">self</span>):<br>        x = <span class="hljs-string">&quot;this&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;h&quot;</span> <span class="hljs-keyword">in</span> x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two</span>(<span class="hljs-params">self</span>):<br>        x = <span class="hljs-string">&quot;hello&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">hasattr</span>(x, <span class="hljs-string">&quot;check&quot;</span>)<br></code></pre></td></tr></table></figure><p>pytest会根据我们之前提到的python测试发现的规定来发现所有的测试，所以它会找到所有以test_为前缀的函数。不需要通过继承任何类来实现，但是确保你的类的前缀是<code>Test</code>，否则这个类会被跳过。我们可以通过传递文件名来运行模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest -q test_class.py</span><br>.F                                                                   [100%]<br>================================= FAILURES =================================<br>____________________________ TestClass.test_two ____________________________<br><br>self = &lt;test_class.TestClass object at 0xdeadbeef0001&gt;<br><br>    def test_two(self):<br>        x = &quot;hello&quot;<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">      assert hasattr(x, <span class="hljs-string">&quot;check&quot;</span>)</span><br>E       AssertionError: assert False<br>E        +  where False = hasattr(&#x27;hello&#x27;, &#x27;check&#x27;)<br><br>test_class.py:8: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_class.py::TestClass::test_two - AssertionError: assert False<br>1 failed, 1 passed in 0.12s<br></code></pre></td></tr></table></figure><p>第一个测试通过了，第二个测试失败了。你可以很容易地看到断言中的中间值，帮助你理解失败的原因。</p><p>将测试分组到类中可能有以下好处：</p><ul><li>方便组织测试用例</li><li>仅在该特定类中共享fixtures</li><li>在类级别应用标记，并隐式地应用到所有测试</li></ul><p>当在类中分组测试时，需要注意的是每个测试用例都对分别对该类进行实例化，所以类的值不能在测试用例之间共享。让每个测试共享同一个类实例对测试隔离非常不利。这在下面有详细说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_class_demo.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassDemoInstance</span>:<br>    value = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_one</span>(<span class="hljs-params">self</span>):<br>        self.value = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">assert</span> self.value == <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> self.value == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest -k TestClassDemoInstance -q</span><br>.F                                                                   [100%]<br>================================= FAILURES =================================<br>______________________ TestClassDemoInstance.test_two ______________________<br><br>self = &lt;test_class_demo.TestClassDemoInstance object at 0xdeadbeef0002&gt;<br><br>    def test_two(self):<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">      assert self.value == 1</span><br>E       assert 0 == 1<br>E        +  where 0 = &lt;test_class_demo.TestClassDemoInstance object at 0xdeadbeef0002&gt;.value<br><br>test_class_demo.py:9: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_class_demo.py::TestClassDemoInstance::test_two - assert 0 == 1<br>1 failed, 1 passed in 0.12s<br></code></pre></td></tr></table></figure><p>请注意，添加&#x2F;更改类级别的属性是类属性，它们会在测试用例之间共享。有关类属性和实例属性以及命名空间的概念属于python的语法知识，此处不做解释。</p><h4 id="为功能测试请求一个特殊的临时目录"><a href="#为功能测试请求一个特殊的临时目录" class="headerlink" title="为功能测试请求一个特殊的临时目录"></a>为功能测试请求一个特殊的临时目录</h4><p><code>pytest</code>提供了内置的fixtures&#x2F;函数参数来请求任意资源，比如一个唯一的临时目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_tmp_path.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_needsfiles</span>(<span class="hljs-params">tmp_path</span>):<br>    <span class="hljs-built_in">print</span>(tmp_path)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在测试函数签名中列出 <code>tmp_path</code> 名称，<code>pytest</code>将查找并调用一个<code>fixture factory</code>来在执行测试函数调用之前创建资源。在测试运行之前，<code>pytest</code>会创建一个每次测试调用都唯一的临时目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest -q test_tmp_path.py</span><br>F                                                                    [100%]<br>================================= FAILURES =================================<br>_____________________________ test_needsfiles ______________________________<br><br>tmp_path = PosixPath(&#x27;PYTEST_TMPDIR/test_needsfiles0&#x27;)<br><br>    def test_needsfiles(tmp_path):<br>        print(tmp_path)<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">      assert 0</span><br>E       assert 0<br><br>test_tmp_path.py:3: AssertionError<br>--------------------------- Captured stdout call ---------------------------<br>PYTEST_TMPDIR/test_needsfiles0<br>========================= short test summary info ==========================<br>FAILED test_tmp_path.py::test_needsfiles - assert 0<br>1 failed in 0.12s<br></code></pre></td></tr></table></figure><p>关于临时目录的相信文档可以在 <a href="https://docs.pytest.org/en/stable/how-to/tmp_path.html#tmp-path-handling">Temporary directories and files</a>找到。</p><p>你可以使用以下命令查看哪些内置的<code>pytest fixtures</code>存在，并且有一个简单的pydoc说明这个fixture是做什么的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pytest --fixtures   # 显示内置和自定义的fixtures<br></code></pre></td></tr></table></figure><p>注意，除非添加了 <code>-v</code> 选项，否则这个命令会省略以 <code>_</code> 开头的fixtures。</p><p><a href="https://github.com/DouyuShinyruo/pytest">Demo Repo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10分钟搭建Cucumber框架</title>
    <link href="/shinyruotechtips/2024/01/a9e472a14e25/"/>
    <url>/shinyruotechtips/2024/01/a9e472a14e25/</url>
    
    <content type="html"><![CDATA[<h4 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h4><p>在我们开始之前，需要以下内容：</p><ul><li>Java SE</li><li>构建工具。此处选择：<ul><li>Maven - 版本3.3.1或更高</li><li>IntelliJ IDEA</li><li>IntelliJ IDEA Cucumber for Java 插件</li></ul></li></ul><p>首先使用cucumber-archetype Maven插件创建一个空的Cucumber项目，在要创建项目的目录下打开本地Terminal，并运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn archetype:generate <span class="hljs-string">&quot;-DarchetypeGroupId=io.cucumber&quot;</span> <span class="hljs-string">&quot;-DarchetypeArtifactId=cucumber-archetype&quot;</span> <span class="hljs-string">&quot;-DarchetypeVersion=7.15.0&quot;</span> <span class="hljs-string">&quot;-DgroupId=com.shinyruo&quot;</span>  <span class="hljs-string">&quot;-DartifactId=hellocucumber&quot;</span> <span class="hljs-string">&quot;-Dpackage=hellocucumber&quot;</span> <span class="hljs-string">&quot;-Dversion=1.0.0-SNAPSHOT&quot;</span>    <span class="hljs-string">&quot;-DinteractiveMode=false&quot;</span>如果你本地没有这个插件的话，这个命令需要运行一会儿，<br></code></pre></td></tr></table></figure><p>如果本地没有这个插件，Maven会自动下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INFO] Project created from Archetype <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>: &lt;directory <span class="hljs-built_in">where</span> you created the project&gt;/cucumber<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>在IntelliJ IDEA中打开项目，运行Cucumber试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>应该会看到类似以下的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 s -- <span class="hljs-keyword">in</span> hellocucumber.RunCucumberTest<br>[INFO] <br>[INFO] Results:<br>[INFO]<br>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0<br>[INFO]<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>Cucumber此处运行了example.feature这个文件中给出的示例场景（Scenario）。</p><h4 id="写一个场景（Scenario）"><a href="#写一个场景（Scenario）" class="headerlink" title="写一个场景（Scenario）"></a>写一个场景（Scenario）</h4><p>在Cucumber中进行行为驱动开发时，我们使用具体的示例来指定软件应该做什么。场景在生成代码之前编写。它们开始作为可执行规范。随着生成代码的出现，场景将扮演实时文档和自动化测试的角色。</p><p>在Cucumber中，一个示例被称为场景（Scenario）。场景定义在.feature文件中，这些文件默认存储在src&#x2F;test&#x2F;resources&#x2F;hellocucumber目录（或子目录）中，当然，根据项目的需要，我们可以更改这个配置，在指定的目录下存储对应的.feature文件。比如在这个项目中，我们给RunCucumberTest加上这个注解<code>@ConfigurationParameter(key = FEATURES_PROPERTY_NAME, value = &quot;src/test/resources/features&quot;)</code>就把这个目录更改为了src&#x2F;test&#x2F;resources&#x2F;features这个目录（或子目录）。</p><p>接下来我们通过一个例子来表明应该如何写一个具体的场景。</p><p>创建一个src&#x2F;test&#x2F;resources&#x2F;features&#x2F;is_it_friday_yet.feature文件，内容如下：</p><figure class="highlight feature"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs feature"><span class="hljs-keyword">Feature</span>: Is it Friday yet?<br>  Everybody wants to know when it&#x27;s Friday<br><br>  <span class="hljs-keyword">Scenario</span>: Sunday isn&#x27;t Friday<br>    <span class="hljs-keyword">Given</span> today is Sunday<br>    <span class="hljs-keyword">When</span> I ask whether it&#x27;s Friday yet<br>    <span class="hljs-keyword">Then</span> I should be told <span class="hljs-string">&quot;Nope&quot;</span><br></code></pre></td></tr></table></figure><p>这个文件的第一行以关键字Feature:开头，后面跟着一个名称。可以使用与文件名相似的名称，或者根据业务需求对功能本身进行概括。</p><p>第二行是功能的简要描述。Cucumber不执行此行，因为它是文档&#x2F;注释的一部分。</p><p>第四行，Scenario: Sunday isn’t Friday是一个场景，它是一个具体的示例，说明在这里软件所处的状态，或者业务场景。</p><p>以Given，When和Then开头的最后三行是我们场景的步骤。这是Cucumber将执行的内容。</p><h4 id="查看报告中的未定义场景"><a href="#查看报告中的未定义场景" class="headerlink" title="查看报告中的未定义场景"></a>查看报告中的未定义场景</h4><p>现在我们有了一个场景，我们可以要求Cucumber执行它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>Cucumber告诉我们有一个未定义的场景和三个未定义的步骤。它还建议一些代码片段，我们可以用这些代码片段来定义这些步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash">Scenario: Sunday isn<span class="hljs-string">&#x27;t Friday        # src/test/resources/features/is_it_friday_yet.feature:4</span><br><span class="hljs-string">  Given today is Sunday</span><br><span class="hljs-string">  When I ask whether it&#x27;</span>s Friday yet<br>  Then I should be told <span class="hljs-string">&quot;Nope&quot;</span><br>[ERROR] Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.142 s &lt;&lt;&lt; <span class="hljs-string">FAILURE! -- in hellocucumber.RunCucumberTest</span><br><span class="hljs-string">[ERROR] Is it Friday yet?.Sunday isn&#x27;t Friday -- Time elapsed: 0.024 s &lt;&lt;&lt; ERROR!</span><br><span class="hljs-string">io.cucumber.junit.platform.engine.UndefinedStepException:</span><br><span class="hljs-string">The step &#x27;today is Sunday&#x27; and 2 other step(s) are undefined.</span><br><span class="hljs-string">You can implement these steps using the snippet(s) below:</span><br><span class="hljs-string"></span><br><span class="hljs-string">@Given(&quot;today is Sunday&quot;)</span><br><span class="hljs-string">public void today_is_sunday() &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">@When(&quot;I ask whether it&#x27;s Friday yet&quot;)</span><br><span class="hljs-string">public void i_ask_whether_it_s_friday_yet() &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">@Then(&quot;I should be told &#123;string&#125;&quot;)</span><br><span class="hljs-string">public void i_should_be_told(String string) &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        at io.cucumber.core.runtime.TestCaseResultObserver.assertTestCasePassed(TestCaseResultObserver.java:69)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.TestCaseResultObserver.assertTestCasePassed(TestCaseResultObserver.java:22)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.CucumberEngineExecutionContext.lambda$runTestCase$4(CucumberEngineExecutionContext.java:114)</span><br><span class="hljs-string">        at io.cucumber.core.runtime.CucumberExecutionContext.lambda$runTestCase$5(CucumberExecutionContext.java:137)</span><br><span class="hljs-string">        at io.cucumber.core.runtime.RethrowingThrowableCollector.executeAndThrow(RethrowingThrowableCollector.java:23)</span><br><span class="hljs-string">        at io.cucumber.core.runtime.CucumberExecutionContext.runTestCase(CucumberExecutionContext.java:137)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.CucumberEngineExecutionContext.runTestCase(CucumberEngineExecutionContext.java:109)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.NodeDescriptor$PickleDescriptor.execute(NodeDescriptor.java:168)</span><br><span class="hljs-string">        at io.cucumber.junit.platform.engine.NodeDescriptor$PickleDescriptor.execute(NodeDescriptor.java:90)</span><br><span class="hljs-string">        at java.util.ArrayList.forEach(ArrayList.java:1259)</span><br><span class="hljs-string">        at java.util.ArrayList.forEach(ArrayList.java:1259)</span><br><span class="hljs-string"></span><br><span class="hljs-string">[INFO] </span><br><span class="hljs-string">[INFO] Results:</span><br><span class="hljs-string">[INFO]</span><br><span class="hljs-string">[ERROR] Errors: </span><br><span class="hljs-string">[ERROR]   The step &#x27;today is Sunday&#x27; and 2 other step(s) are undefined.</span><br><span class="hljs-string">You can implement these steps using the snippet(s) below:</span><br><span class="hljs-string"></span><br><span class="hljs-string">@Given(&quot;today is Sunday&quot;)</span><br><span class="hljs-string">public void today_is_sunday() &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">@When(&quot;I ask whether it&#x27;s Friday yet&quot;)</span><br><span class="hljs-string">public void i_ask_whether_it_s_friday_yet() &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">@Then(&quot;I should be told &#123;string&#125;&quot;)</span><br><span class="hljs-string">public void i_should_be_told(String string) &#123;</span><br><span class="hljs-string">    // Write code here that turns the phrase above into concrete actions</span><br><span class="hljs-string">    throw new io.cucumber.java.PendingException();</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>复制每个未定义步骤的三个代码片段，并将它们粘贴到src&#x2F;test&#x2F;java&#x2F;hellocucumber&#x2F;stepdefs&#x2F;common&#x2F;Friday.java中。</p><p>再次运行Cucumber。这次输出有点不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.107 s &lt;&lt;&lt; <span class="hljs-string">FAILURE! -- in hellocucumber.RunCucumberTest</span><br><span class="hljs-string">[ERROR] Is it Friday yet?.Sunday isn&#x27;t Friday -- Time elapsed: 0.007 s &lt;&lt;&lt; ERROR!</span><br><span class="hljs-string">io.cucumber.java.PendingException: TODO: implement me</span><br><span class="hljs-string">        at hellocucumber.stepdefs.common.Friday.today_is_sunday(Friday.java:9)</span><br></code></pre></td></tr></table></figure><p>Cucumber找到了我们的步骤定义并执行了它们。它们当前标记为挂起，这意味着我们需要使它们做一些有用的事情，也就是对这些step进行实现。</p><h4 id="查看报告中的失败-x2F-通过场景"><a href="#查看报告中的失败-x2F-通过场景" class="headerlink" title="查看报告中的失败&#x2F;通过场景"></a>查看报告中的失败&#x2F;通过场景</h4><p>下一步是按步骤定义中的注释所示做一些事情：</p><p>“&#x2F;&#x2F; Write code here that turns the phrase above into concrete actions”</p><p>将步骤定义代码src&#x2F;test&#x2F;java&#x2F;com&#x2F;shinyruo&#x2F;hellocucumber&#x2F;stepdefs&#x2F;common&#x2F;Friday.java更改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shinyruo.hellocucumber.stepdefs.common;<br><br><span class="hljs-keyword">import</span> io.cucumber.java.en.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Friday</span> &#123;<br>    <span class="hljs-keyword">private</span> String today;<br>    <span class="hljs-keyword">private</span> String actualAnswer;<br><br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">isItFriday</span><span class="hljs-params">(String today)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Given(&quot;today is Sunday&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">today_is_Sunday</span><span class="hljs-params">()</span> &#123;<br>        today = <span class="hljs-string">&quot;Sunday&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@When(&quot;I ask whether it&#x27;s Friday yet&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">i_ask_whether_it_s_Friday_yet</span><span class="hljs-params">()</span> &#123;<br>        actualAnswer = isItFriday(today);<br>    &#125;<br><br>    <span class="hljs-meta">@Then(&quot;I should be told &#123;string&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">i_should_be_told</span><span class="hljs-params">(String expectedAnswer)</span> &#123;<br>        assertEquals(expectedAnswer, actualAnswer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行Cucumber：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Is it Friday yet?.Sunday isn<span class="hljs-string">&#x27;t Friday -- Time elapsed: 0.009 s &lt;&lt;&lt; FAILURE!</span><br><span class="hljs-string">org.opentest4j.AssertionFailedError: expected: &lt;Nope&gt; but was: &lt;null&gt;</span><br><span class="hljs-string">        at com.shinyruo.hellocucumber.stepdefs.common.Friday.i_should_be_told(Friday.java:26)</span><br><span class="hljs-string">        at ?.I should be told &quot;Nope&quot;</span><br></code></pre></td></tr></table></figure><p>前两个步骤通过了，但是最后一个步骤失败了。很明显，这是因为我们的方法中返回了null，我们把它改成Nope：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String <span class="hljs-title function_">isItFriday</span><span class="hljs-params">(String today)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Nope&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行Cucumber：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INFO] Running com.shinyruo.hellocucumber.RunCucumberTest<br><br>Scenario: The example                       <span class="hljs-comment"># src/test/resources/features/example.feature:3</span><br>  Given an example scenario                 <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.StepDefinitions.anExampleScenario()</span><br>  When all step definitions are implemented <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.StepDefinitions.allStepDefinitionsAreImplemented()</span><br>  Then the scenario passes                  <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.StepDefinitions.theScenarioPasses()</span><br><br>Scenario: Sunday isn<span class="hljs-string">&#x27;t Friday        # src/test/resources/features/is_it_friday_yet.feature:4</span><br><span class="hljs-string">  Given today is Sunday              # com.shinyruo.hellocucumber.stepdefs.common.Friday.today_is_Sunday()</span><br><span class="hljs-string">  When I ask whether it&#x27;</span>s Friday yet <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.Friday.i_ask_whether_it_s_Friday_yet()</span><br>  Then I should be told <span class="hljs-string">&quot;Nope&quot;</span>       <span class="hljs-comment"># com.shinyruo.hellocucumber.stepdefs.common.Friday.i_should_be_told(java.lang.String)</span><br>[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.100 s -- <span class="hljs-keyword">in</span> com.shinyruo.hellocucumber.RunCucumberTest<br>[INFO] <br>[INFO] Results:<br>[INFO]<br>[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0<br>[INFO]<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>现在，我们的用例就都是通过状态了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总之，我们现在有了一个非常简陋的cucumber框架，更复杂的场景以及与其他测试工具的集成我们可以后边逐步实现。</p><p><a href="https://github.com/DouyuShinyruo/cucumber">Demo Repo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Cucumber</tag>
      
      <tag>Framework</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北美科技公司对工程技术角色的区分</title>
    <link href="/shinyruotechtips/2024/01/72ac063e860c/"/>
    <url>/shinyruotechtips/2024/01/72ac063e860c/</url>
    
    <content type="html"><![CDATA[<p>科普一下北美科技公司对工程技术角色的区分，比如 EM(Engineering Manager)、TPM (Technical Program Manager) 都代表什么意思，分工有什么不同？</p><p>通常北美的工程技术相关的职业分成以下五个类别：</p><ul><li>开发工程师 SE &#x2F; SDE(Software Engineer &#x2F; Software Development Engineer)</li><li>工程经理 EM &#x2F; SDM(Engineering Manager &#x2F; Software Development Manager)</li><li>技术主管 TL &#x2F; TLM (Tech Lead &#x2F; Tech Lead Manager)</li><li>技术项目经理 TPM (Technical Program Manager)</li><li>产品经理 PM (Product Manager)</li></ul><p>这些角色之间的差别很难描述，知名技术专栏 The Pragmatic Engineer 的作者，前 Uber 的工程经理 Gergely Orosz 写过一篇文章：《<a href="https://newsletter.pragmaticengineer.com/p/engineering-leadership-skillset-overlaps">Engineering Leadership Skill Set Overlaps</a>》，从三个维度来区分这些角色之间的差别，相对比较准确客观。</p><p><img src="/shinyruotechtips/imgs/%E5%8C%97%E7%BE%8E%E7%A7%91%E6%8A%80%E5%85%AC%E5%8F%B8%E5%AF%B9%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF%E8%A7%92%E8%89%B2%E7%9A%84%E5%8C%BA%E5%88%86/2024-01-23-16-27-27-image.png"></p><p>这三个维度分别是：</p><ul><li>战略对齐：明确组织的愿景、使命和战略；与团队工作在一起，保持战略上的一致，避免资源上的浪费；保持各团队之间信息通畅，处理好团队之间的依赖关系，让团队一起协作。</li><li>人员管理：确保团队健康，帮助团队成员成长，推动团队的执行。</li><li>软件开发：与生成产品代码直接相关的工作，比如系统设计、编码、代码审查、部署、监控等等。</li></ul><p>虽然这三个维度不足以覆盖各个工程角色中的所有活动（比如行政、招聘），但确实可以很好的用可视化的方式来区分各个工程角色的差别。</p><p>让我们具体看一下各个角色的主要工作职责：</p><h4 id="开发工程师-SE-x2F-SDE-Software-Engineer-x2F-Software-Development-Engineer"><a href="#开发工程师-SE-x2F-SDE-Software-Engineer-x2F-Software-Development-Engineer" class="headerlink" title="开发工程师 SE &#x2F; SDE(Software Engineer &#x2F; Software Development Engineer)"></a>开发工程师 SE &#x2F; SDE(Software Engineer &#x2F; Software Development Engineer)</h4><ul><li>开发工程师主要以技术开发为主</li><li>资深的工程师会参与一些跨团队的协作，以及指导新手工程师</li><li>不会涉及人员管理</li></ul><h4 id="工程经理-EM-x2F-SDM-Engineering-Manager-x2F-Software-Development-Manager"><a href="#工程经理-EM-x2F-SDM-Engineering-Manager-x2F-Software-Development-Manager" class="headerlink" title="工程经理 EM &#x2F; SDM(Engineering Manager &#x2F; Software Development Manager)"></a>工程经理 EM &#x2F; SDM(Engineering Manager &#x2F; Software Development Manager)</h4><ul><li>工程经理则以人员管理为主，要花大量时间在团队建设和帮助员工成长上面</li><li>需要将组织的战略和团队以及团队成员对齐，确保团队做的事情和部门或公司的目标是一致的</li><li>要和产品经理、技术项目经理协作，参与项目管理，设定项目目标，制定项目计划，推动项目进展</li><li>软件开发相关的工作占比极少，通常只是参与技术决策和代码审查，即使参与开发也不应负责关键模块，否则容易成为团队瓶颈</li></ul><h4 id="技术主管-TL-x2F-TLM-Tech-Lead-x2F-Tech-Lead-Manager"><a href="#技术主管-TL-x2F-TLM-Tech-Lead-x2F-Tech-Lead-Manager" class="headerlink" title="技术主管 TL &#x2F; TLM (Tech Lead &#x2F; Tech Lead Manager)"></a>技术主管 TL &#x2F; TLM (Tech Lead &#x2F; Tech Lead Manager)</h4><ul><li>技术主管会直接参与开发，和工程师相比比例要低一些，还要帮助团队做出技术决策</li><li>技术主管有少量的人员管理职责，以技术指导为主，一般不会涉及绩效、人事相关</li><li>技术主管会和产品经理协作推动项目进展，偏项目执行层面</li></ul><h4 id="技术项目经理-TPM-Technical-Program-Manager"><a href="#技术项目经理-TPM-Technical-Program-Manager" class="headerlink" title="技术项目经理 TPM (Technical Program Manager)"></a>技术项目经理 TPM (Technical Program Manager)</h4><ul><li>技术项目经理主要职责是管理推动跨多个团队的大型复杂项目</li><li>通常不涉及人员管理，除非是资深的 TPM 下面还带 TPM</li><li>要花大量时间和 stakeholders（利益相关方）沟通协作，从而推动项目进展</li></ul><h4 id="产品经理-PM-Product-Manager"><a href="#产品经理-PM-Product-Manager" class="headerlink" title="产品经理 PM (Product Manager)"></a>产品经理 PM (Product Manager)</h4><ul><li><p>产品经理需要将组织的战略转化成产品设计</p></li><li><p>产品经理需要花大量时间和 SDE、EM、TPM 一起协作，确保产品设计能被理解和执行</p></li><li><p>产品经理通常不涉及人员管理，除非是资深产品经理或产品总监，有直接下属</p></li><li><p>职责和角色的对应关系</p></li></ul><p>除了上面说的软件开发、战略对齐和人员管理三种维度，还有一种更简单直接的区分方法是按照职责来划分，将职责划分成：项目管理 (Project Management)、人员管理 (People Management) 和技术 (Technical Leadership) 三部分。</p><ul><li><strong>工程经理（EM）</strong> 以人员管理为主，但是也会兼顾一部分的技术和项目管理</li><li><strong>技术主管（TL）</strong> 以技术为主，兼顾少量项目管理和人员管理</li><li><strong>项目经理（TPM）</strong> 以项目管理为主，不怎么参与人员管理和技术</li></ul><p>以上就是通常北美的大型科技公司在技术公司工程团队中各个角色的介绍，以及区分。</p><h3 id="不同的体量的公司中各个角色分别负责什么？"><a href="#不同的体量的公司中各个角色分别负责什么？" class="headerlink" title="不同的体量的公司中各个角色分别负责什么？"></a>不同的体量的公司中各个角色分别负责什么？</h3><p>不同的公司由于团队规模不一样，所以角色划分也有所不同，上面的划分主要是针对大型科技公司的组织架构来划分的角色，对于中小公司其实没有那么细。比如创业公司老板什么都做，中小型公司没有 TPM（技术项目经理），只有大公司才会有专门的 TPM 去组织管理跨多个团队的项目。</p><p>如果我们把一个项目按照 WWHWW 拆分：</p><ul><li><strong>Why？</strong> 为什么要做？</li><li><strong>What？</strong> 项目的目标是什么？做成什么样？</li><li><strong>How？</strong> 项目要如何完成？技术方案、系统架构是什么？</li><li><strong>When？</strong> 项目何时可以交付？Roadmap 和计划是什么？</li><li><strong>Who？</strong> 安排谁来做这个项目？</li></ul><p>那么通常产品经理（PM）是负责解决 Why 和 What 的，解释清楚为什么要立项，要做成什么样。也就是我们通常说的立项和项目需求。</p><p>在确定需求后，工程经理（EM）就要负责去评估时间（When），安排人手（Who），和团队的工程师一起做出技术方案（How）并推动项目完成。通常 EM 只负责本团队的项目。</p><p>在大公司，一些复杂的项目需要多个团队一起协作，这种情况下单靠 PM 和 EM 是不够的，所以这时候通常会需要技术项目经理（TPM）的帮助，对于跨团队的大项目，TPM 和 PM 以及各个团队的 EM 一起协作，定义好 Roadmap（When），任务分解到各个团队（Who），解决项目中的问题，推动项目的执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown Syntax Guide</title>
    <link href="/shinyruotechtips/2024/01/c5d07596ae69/"/>
    <url>/shinyruotechtips/2024/01/c5d07596ae69/</url>
    
    <content type="html"><![CDATA[<p>This article offers a sample of basic Markdown syntax.</p><h1 id="Titles"><a href="#Titles" class="headerlink" title="Titles"></a>Titles</h1><p>As we started writing a markdown document, we need to add a title and some sub-headers.</p><p>Markdown supports two styles of headers, Setext and atx.</p><p>Setext-style headers are “underlined” using equal signs (for first-level headers) and dashes (for second-level headers). For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">This is an H1</span><br><span class="hljs-section">=============</span><br><br><span class="hljs-section">This is an H2</span><br><span class="hljs-section">-------------</span><br></code></pre></td></tr></table></figure><p>Any number of underlining &#x3D;’s or -’s will work.</p><p>Atx-style headers use 1-6 hash characters at the start of the line, corresponding to header levels 1-6. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># This is an H1</span><br><br><span class="hljs-section">## This is an H2</span><br><br><span class="hljs-section">###### This is an H6</span><br></code></pre></td></tr></table></figure><p>Optionally, you may “close” atx-style headers. This is purely cosmetic — you can use this if you think it looks better. The closing hashes don’t even need to match the number of hashes used to open the header. (The number of opening hashes determines the header level.) :</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># This is an H1 #</span><br><br><span class="hljs-section">## This is an H2 ##</span><br><br><span class="hljs-section">### This is an H3 ######</span><br></code></pre></td></tr></table></figure><h1 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h1><p>Tables aren’t part of the core Markdown spec, but they are part of GFM (GitHub Markdown) and Markdown Here supports them.</p><p>Here is an example of table with the output below:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Tables        </span>|<span class="hljs-string"> Are           </span>|<span class="hljs-string"> Cool  </span>|<br>|<span class="hljs-string"> ------------- </span>|<span class="hljs-string">:-------------:</span>|<span class="hljs-string"> -----:</span>|<br>|<span class="hljs-string"> col 3 is      </span>|<span class="hljs-string"> right-aligned </span>|<span class="hljs-string"> $1600 </span>|<br>|<span class="hljs-string"> col 2 is      </span>|<span class="hljs-string"> centered      </span>|<span class="hljs-string">   $12 </span>|<br>|<span class="hljs-string"> zebra stripes </span>|<span class="hljs-string"> are neat      </span>|<span class="hljs-string">    $1 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>Colons can be used to align columns.</p><p>The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown.</p><p>Example:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Markdown |<span class="hljs-string"> Less </span>|<span class="hljs-string"> Pretty</span><br><span class="hljs-string">--- </span>|<span class="hljs-string"> --- </span>|<span class="hljs-string"> ---</span><br><span class="hljs-string">*Still* </span>|<span class="hljs-string"> `renders` </span>|<span class="hljs-string"> **nicely**</span><br><span class="hljs-string">1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3</span><br></code></pre></td></tr></table></figure><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><p>Markdown supports two styles of links: inline and reference.</p><p>In both styles, the link text is delimited by [square brackets].</p><p>To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">I&#x27;m an inline-style link</span>](<span class="hljs-link">https://www.google.com</span>)<br><br>[<span class="hljs-string">I&#x27;m an inline-style link with title</span>](<span class="hljs-link">https://www.google.com &quot;Google&#x27;s Homepage&quot;</span>)<br><br>[<span class="hljs-string">I&#x27;m a reference-style link</span>][<span class="hljs-symbol">arbitrary case-insensitive reference text</span>]<br><br>[<span class="hljs-string">I&#x27;m a relative reference to a repository file</span>](<span class="hljs-link">../blob/master/LICENSE</span>)<br></code></pre></td></tr></table></figure><p>Reference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is [<span class="hljs-string">an example</span>][<span class="hljs-symbol">id</span>] reference-style link.<br></code></pre></td></tr></table></figure><p>You can optionally use a space to separate the sets of brackets:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is [an example] [id] reference-style link.<br></code></pre></td></tr></table></figure><p>Then, anywhere in the document, you define your link label like this, on a line by itself:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">id</span>]: <span class="hljs-link">http://example.com/ &quot;Optional Title Here&quot;</span><br></code></pre></td></tr></table></figure><p><strong>GitHub</strong> and <strong>GitBook</strong> supports URL autolinking. They will autolink standard URLs, so if you want to link to a URL (instead of setting link text), you can simply enter the URL and it will be turned into a link to that URL.</p><h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Inline</span><br><br>![<span class="hljs-string">Alternative text</span>](<span class="hljs-link">/path/to/img.jpg &quot;Optional title&quot;</span>)<br><br><span class="hljs-section"># Reference</span><br><br>![<span class="hljs-string">Alternative text</span>][<span class="hljs-symbol">id</span>]<br>[<span class="hljs-symbol">id</span>]: <span class="hljs-link">url/to/image &quot;Optional title&quot;</span><br></code></pre></td></tr></table></figure><p>As you may have noticed, images in Markdown are very similar to links. The difference is that:</p><ul><li>the square brackets must be prefixed with an exclamation mark and</li><li>inside they may have some alternative text. A description of the image, which is displayed if the image can’t be loaded.</li></ul><h1 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code Blocks"></a>Code Blocks</h1><p>Pre-formatted code blocks are used for writing about programming or markup source code. Rather than forming normal paragraphs, the lines of a code block are interpreted literally.</p><p>Here is an example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is a code block<br></code></pre></td></tr></table></figure><p>To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab.</p><p>For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is a normal paragraph:<br><br><span class="hljs-code">    This is a code block.</span><br></code></pre></td></tr></table></figure><p>You can also create code block separated by:</p><pre><code class="hljs"><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### Inline <span class="hljs-keyword">code</span> blocks<br><br>Inline <span class="hljs-keyword">code</span> blocks can be written using: `<br><br>For example:<br><br>    This is a `<span class="hljs-keyword">inline</span> <span class="hljs-keyword">code</span> block`<br><br>### Syntax highlighting<br><br>You can define the language to be used for syntax highlighting by adding the name on the opening tag. Example:<br><br>    ```javascript<br>    var a = &#123;&#125;;<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
