<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何配置一个DNS服务？</title>
    <link href="/shinyruotechtips/2022/12/1323966e29b7/"/>
    <url>/shinyruotechtips/2022/12/1323966e29b7/</url>
    
    <content type="html"><![CDATA[<p>今天在工作中遇到一个需要配置DNS Server的问题，记录一下。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在配置DNS Server之前，我们要先了解，什么是DNS？我第一次接触DNS是在我家跨上了“信息高速路”之后的一天，那时候我还是一个小学生，一个周末我快乐地打开电脑准备进入4399小游戏来一把的时候，却发现无法连上互联网。我感到非常的意外，因为就在那时我还可以使用QQ和朋友们愉快地聊天。但是当时的我并不知道这个问题是什么原因，也并不会修复，后来还是给运营商的维修师傅打电话才把这个问题修复好了。直到后来我才知道是因为DNS出了问题，而QQ是直接使用IP地址来连接服务器，所以即使DNS失效，QQ也可以正常使用。</p><p>如果根据DNS的作用来说，DNS就是一个电话簿，在这个电话簿上记录了访问的网址对应的IP地址。对于DNS的产生和历史，此处不再赘述，我们只需要知道DNS协议运行在UDP协议上，使用端口号53。</p><h1 id="DNS是怎么工作的？"><a href="#DNS是怎么工作的？" class="headerlink" title="DNS是怎么工作的？"></a>DNS是怎么工作的？</h1><p>DNS系统采用的是分布式的解析方案，整个DNS架构是一种层次树状结构，这个树状结构称为DNS域名空间，如下图所示：</p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%EF%BC%9F/2022-12-20-21-32-00-image.png"></p><p><a href="https://root-servers.org/">Root Server Technical Operations Association (root-servers.org)</a>如果有兴趣的话，在这个网站上可以查看所有根域服务器。</p><p>主机名和域名结合构成了FQDN<a href="https://en.wikipedia.org/wiki/Fully_qualified_domain_name">Fully qualified domain name - Wikipedia</a>，比如<a href="http://www.bing.com.就是一个fqdn./">www.bing.com.就是一个FQDN。</a></p><blockquote><p>注1：FQDN只能包含26个英文字母、“0-9”十个数字和“-”英文中的连接号，且开头和结尾不能含有这个连接号。中文域名包含两到十五个汉字之间的字词或词组。域名中不能包含空格及符号如？&#x2F;；：@#$%^~_&#x3D;+&amp;。等。</p></blockquote><blockquote><p>注2: 每个域名的最后面有一个点号“.”表示根域名，实际使用的时候为了方便省略掉。</p></blockquote><h1 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h1><p>整个DNS的域名解析过程是什么样的呢？</p><h5 id="1-本地缓存"><a href="#1-本地缓存" class="headerlink" title="1.本地缓存"></a>1.本地缓存</h5><p>当我们在浏览器中输入一个域名的时候，首先会去浏览器的 dns 缓存中去查询是否有对应记录。如果查询到记录就可以直接返回 ip 地址，完成解析。同上，如果浏览器没有对应的缓存，就去查询操作系统的缓存。</p><h5 id="2-hosts"><a href="#2-hosts" class="headerlink" title="2.hosts"></a>2.hosts</h5><p>当缓存中没有记录的时候，去检查本地的hosts(C:\Windows\System32\drivers\etc\hosts)文件是否有这个网址的映射关系.</p><h5 id="3-本地DNS服务器"><a href="#3-本地DNS服务器" class="headerlink" title="3.本地DNS服务器"></a>3.本地DNS服务器</h5><p>一般来说，本地DNS一般本地的互联网运营商提供，由DHCP自动分配，当然也可以由使用者手动配置。</p><img src="../imgs/如何配置一个DNS服务？/2022-12-20-22-17-26-image.png" title="" alt="" width="383"><p>当hosts没有对应映射时，查找本地DNS服务器缓存。如果该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p><h5 id="4-根域名-x2F-上级服务器"><a href="#4-根域名-x2F-上级服务器" class="headerlink" title="4.根域名&#x2F;上级服务器"></a>4.根域名&#x2F;上级服务器</h5><p>这里根据本地DNS服务器是否设置了转发器，有两种情况。</p><p><strong>未启用转发模式：</strong> 本地DNS把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(baidu.com)给本地DNS服务器，直到找到主机。</p><p><strong>启用转发模式：</strong> 此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p><p>这就是DNS系统的作用：</p><p>    正向解析：根据主机名称（域名）查找对应的IP地址</p><p>    反向解析：根据IP地址查找对应的主机域名</p><p>如果想要更深入地理解DNS的工作原理，我们可以用Wireshark抓一个DNS请求包，并对它的内容进行分析。</p><p>以对<a href="http://www.biying.com的访问作为例子：">www.biying.com的访问作为例子：</a></p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%EF%BC%9F/2022-12-22-21-29-52-image.png"></p><p>可以看到，访问<a href="http://www.biying.com总共产生了四条数据,两次dns请求,第一次查询www.biying.com域名对应的ipv4地址,第二次查询www.biying.com域名对应的ipv6地址./">www.biying.com总共产生了四条数据，两次DNS请求，第一次查询www.biying.com域名对应的IPv4地址，第二次查询www.biying.com域名对应的IPv6地址。</a></p><p><img src="/shinyruotechtips/imgs/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%EF%BC%9F/2022-12-22-21-37-03-image.png"></p><p><strong>报文分析</strong>：</p><p>可以看到，网络传输层使用 UDP 协议，端口号为 53</p><h4 id="DNS报文基础结构部分"><a href="#DNS报文基础结构部分" class="headerlink" title="DNS报文基础结构部分"></a><strong>DNS报文基础结构部分</strong></h4><p>每个字段含义如下。</p><ul><li>事务 ID（Transaction ID）：DNS 报文的 ID 标识。对于请求报文和其对应的应答报文，该字段的值是相同的。通过它可以区分 DNS 应答报文是对哪个请求进行响应的。</li><li>标志（Flags）：DNS 报文中的标志字段。</li><li>问题计数（Questions）：DNS 查询请求的数目。</li><li>回答资源记录数（Answers RRs）：DNS 响应的数目。</li><li>权威名称服务器计数（Authority RRs）：权威名称服务器的数目。</li><li>附加资源记录数（Additional RRs）：额外的记录数目（权威名称服务器对应 IP 地址的数目）。</li></ul><p>   其中Flags字段中每个字段的含义如下：</p><ul><li>QR（Response）：查询请求&#x2F;响应的标志信息。查询请求时，值为 0；响应时，值为 1。</li><li>Opcode：操作码。其中，0 表示标准查询；1 表示反向查询；2 表示服务器状态请求。</li><li>AA（Authoritative）：授权应答，该字段在响应报文中有效。值为 1 时，表示名称服务器是权威服务器；值为 0 时，表示不是权威服务器。</li><li>TC（Truncated）：表示是否被截断。值为 1 时，表示响应已超过 512 字节并已被截断，只返回前 512 个字节。</li><li>RD（Recursion Desired）：期望递归。该字段能在一个查询中设置，并在响应中返回。该标志告诉名称服务器必须处理这个查询，这种方式被称为一个递归查询。如果该位为 0，且被请求的名称服务器没有一个授权回答，它将返回一个能解答该查询的其他名称服务器列表。这种方式被称为迭代查询。</li><li>RA（Recursion Available）：可用递归。该字段只出现在响应报文中。当值为 1 时，表示服务器支持递归查询。</li><li>Z：保留字段，在所有的请求和应答报文中，它的值必须为 0。</li><li>rcode（Reply code）：返回码字段，表示响应的差错状态。<ul><li>当值为 0 时，表示没有错误；</li><li>当值为 1 时，表示报文格式错误（Format error），服务器不能理解请求的报文；</li><li>当值为 2 时，表示域名服务器失败（Server failure），因为服务器的原因导致没办法处理这个请求；</li><li>当值为 3 时，表示名字错误（Name Error），只有对授权域名解析服务器有意义，指出解析的域名不存在；</li><li>当值为 4 时，表示查询类型不支持（Not Implemented），即域名服务器不支持查询类型；</li><li>当值为 5 时，表示拒绝（Refused），一般是服务器由于设置的策略拒绝给出应答，如服务器不希望对某些请求者给出应答，，或者服务器不希望进行某些操作（比如区域传送zone transfer）；</li><li>6-15 保留值，暂时未使用。</li></ul></li></ul><p><strong>DNS报文问题查询部分</strong><br>每个字段含义如下：</p><ul><li>查询名（Name）：一般为要查询的域名胡总和邮件服务器，有时也会是 IP 地址，用于反向查询。</li><li>查询类型（Type）：DNS 查询请求的资源类型。通常查询类型为 A （Address的缩写）类型，表示由域名获取对应的 IP4 地址。（更多类型如 AAAA，CANME，SOA，PTR，NS 等）</li><li>查询类（Class）：地址类型，在设计DNS方案的时候，DNS在除了互联网之外的其他网络中的情况也被考虑到了，所以Class用来识别网络类型，不过，如今除了互联网没有其他的网络了，所以该值为IN。<br>那么，对于上面报文内容，翻译过后的意思就是，“该报文为标准查询(Opcode&#x3D;0)请求(QR&#x3D;1)报文，向本地域名服务器请求查询，发起请求内容为’获取<a href="http://www.biying.com'所对应的ipv4地址,期待本地域名服务器递归查询(rd=1)请求./">www.biying.com&#39;所对应的IPv4地址，期待本地域名服务器递归查询(RD=1)请求。</a></li></ul><p><strong>TODO</strong> 配置DNS服务的实例</p>]]></content>
    
    
    
    <tags>
      
      <tag>-DNS -网络技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Docker到OpenShift（二）</title>
    <link href="/shinyruotechtips/2022/12/3ed6afbd27f8/"/>
    <url>/shinyruotechtips/2022/12/3ed6afbd27f8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Kubernetes与Docker的关系"><a href="#1-Kubernetes与Docker的关系" class="headerlink" title="1.Kubernetes与Docker的关系"></a>1.Kubernetes与Docker的关系</h1><p>在第一次接触到K8s的时候，我以为这个技术和Docker有一定的关系，毕竟一个的logo是驮着集装箱的鲸鱼，而另一个是船的舵轮，都是在虚拟化技术的大海中乘波驶浪的实现方式。</p><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%BA%8C%EF%BC%89/cac5432e5ba26a36ca6d41e9ad6f1ca8d0e0970c.png"></p><p>不过在对K8s有更多的了解后，我认为这两者并不能放在一个维度上进行讨论，两者所面向和解决的问题并不相同。Docker是非常流行的Linux容器解决方案，这我们在之前的文章中已经有了一定的了解。而K8s是一个容器编排的解决方案，主要面向的是集群管理，K8s支持对接多种容器，Docker并不是K8s对容器的唯一选择，比如K8s还支持Apache开源的Mesos容器等等。只要容器实现了K8s容器运行时的接口约定，都可以被K8s调度。</p><p>我认为某种意义上，是容器的大规模使用，引入了新的问题，从而催生了容器的编排技术，把许多Container抽象，对外部使用者来说，并不关心容器内部的应用是如何运行的，而是关注以下问题：</p><ul><li><p>如何部署、调度、管理容器中的应用？</p></li><li><p>如何在升级程序的时候不中断对外的服务？</p></li><li><p>容器里的程序是否是正常运行的？</p></li><li><p>如何方便地根据业务去调整容器里的应用？</p></li></ul><p>其实Docker的公司也推出过他们的容器集群管理方案Docker Swarm，某种意义上是K8s的竞品，但是在IT行业的生产中并没有流行起来，究其原因可能有以下几点：</p><ul><li><p>该方案和Docker绑定的程度太深，Docker本身是非常优秀的container方案，但是Swarm本身的功能非常有限，而且在刚推出的时候并不成熟</p></li><li><p>Google在推出K8s的时候，已经是一个比较成熟的方案了，并且归功于谷歌在大规模集群管理上的经验，谷歌给出的解决方案是非常高屋建瓴并且实用的</p></li><li><p>IT行业的规则是赢者通吃，使用的越为广泛的方案会有更加成熟的社区和公司去推动建设。</p></li></ul><p>虽然K8s的配置更为复杂，但是它同时提供了更为灵活的部署方案，K8s的自动管理生命周期、自动恢复、模块化的架构设计，都是在生产中更具有实用价值的。如果我们想要学习K8s，实际上并不一定要会Docker。学 K8s 更多是让开发的服务能运行在 K8s 集群上，依托 K8s 集群管理、调度的能力让服务变得更具鲁棒性、更便于调整。对于Docker，需要有一个概念上的认知，如果有需要，再去学习就可以了。</p><h1 id="2-K8s的起源"><a href="#2-K8s的起源" class="headerlink" title="2.K8s的起源"></a>2.K8s的起源</h1><p>众所周知，K8s起源于Google的开源，不过K8s的前身，在Google内部真正使用的系统叫做Borg。据说Google在Linux内核还没有CGroup和容器的情况下，造出了同样的东西。也有传言说Google将Brog中的一些边缘技术通过Golang来实现，变成了Kubernetes。当然，Google的说法是K8s吸取了Borg的优秀理念，Google的开源可谓是“纯粹的奉献”。像Google这样的IT行业领头公司，有许多开发的项目，当然也有很多因为各种原因不再继续进行维护的项目，<a href="https://killedbygoogle.com/">Google Graveyard - Killed by Google</a>这个网站记录了Google曾经开发，现在已经是Dead Project的项目。有趣的是，该网站的作者曾经被Google聘请，不过作者本人拒绝了。不得不说，通过开源建立生态，培养用户，吸引企业用户上Google云去获得非阉割版本的性能是很高明的商业策略，这就是巨头的玩法。</p><p>K8s提供了什么？我认为K8s最重要的一点是能够做到把容器部署为服务，这也是IT行业一直说的XaaS（ CaaS、laaS、PaaS）。K8s提供了Pod、Service等机制，帮助用户构建跨多个容器的应用服务、跨集群调度、扩展这些容器，并长期持续管理这些容器的运行健康状况；除此之外，它还可以根据用户设定的策略来自动管理用户的服务。</p><p>如果作为服务的使用者来看，我们关心的是什么？我认为主要是服务的质量与可靠性，也就是说要保持服务的高可用性，这也是2B的IT服务提供商最需要做到的事情。假设有一个服务通过Pod1运行在机器1上，这时候K8s探测到机器1有问题或者处于离线状态，那么K8s就会把这个Pod在另一台机器2上重新拉起，并继续提供对应的服务，看起来这样的方案非常的合理。然而，请思考这样一个问题：我们如何确定机器1确实没有在工作了？在这里我想引入一个电脑领域的假想实验：<a href="https://zh.wikipedia.org/wiki/%E4%B8%A4%E5%86%9B%E9%97%AE%E9%A2%98">Two Generals’ Problem</a>，只有当收到回复并且再次对回复的内容做出回应之后，我们才认为信息是可靠的。然而对于机器1来说，信息显然已经不能再传递，我们应该如何保证机器1上的Pod1没有继续对数据进行修改呢？在分布式集群系统中这是一个非常常见的需要进行处理的问题，这就是“脑裂”（split-brain）现象。我们需要保证新的数据服务启动后，确保旧的服务不在能对数据进行处理或者访问修改，从而保证数据的完整性，这个机制叫Fencing。怎么去解决这个问题，我想IT行业应该已经有许多成熟的方案，而我并不了解，也不是在这里我想要去探讨的问题。</p><p>提到K8s，不得不提的就是“云原生”这个概念。</p><p>TBD</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Docker到OpenShift（一）</title>
    <link href="/shinyruotechtips/2022/12/4757bbfdf288/"/>
    <url>/shinyruotechtips/2022/12/4757bbfdf288/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们还是从最流行的也是最为大众熟知的容器技术产品 Docker 讲起。</p><p>在 2013 年的 PyCon 会议上，Solomon Hykes 利用“闪电演讲”环节，做了题为《The future of Linux Containers》的报告。在B站上有用户上传了当年的报告视频，如果你有兴趣的话可以看一下 <a href="https://www.bilibili.com/video/BV1114y1h7qx">Docker 的诞生</a> 。因为这个环节给每位演讲者的演讲时间只有五分钟，Solomon 只能非常仓促地展示了 docker，期间他还把 world 拼错了，最后还因为超时被主持人请下了台。</p><p>五分钟的演讲时间非常短暂，但他提到了很多新概念：容器、镜像、进程隔离等。这场会议过后，很多云服务厂商意识到这项技术可能会给应用打包、部署、运维提供很多便利，Docker 就这样流行了起来。最终发展到如今的 Kubernetes、服务网格等技术（应用）。</p><p>接下来我们尝试复现一下 Solomon 在 PyCon US 2013 上的演示：</p><p>本文中的操作均在Windows Docker Desktop 命令行下执行。</p><p>首先使用 <code>docker pull</code> 命令拉取一个 <code>busybox</code> 镜像（image）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull busybox<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-51-47-image.png"></p><p>我们稍后再解释 <code>docker pull</code> 的输出</p><p>然后执行下面的命令，查看本地的所有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-52-28-image.png"></p><p>可以看到名为 <code>busybox</code> 的镜像已经被拉取到本地了</p><p>接下来我们就可以利用这个镜像启动容器了，我们要在容器里执行一个 <code>echo</code> 命令，让它输出一个字符串 <code>hello world</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run busybox echo &quot;hello world!&quot;<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-56-59-image.png"></p><p>最后我们再使用 <code>docker ps</code> 命令查看所有容器，我们会在列表中找到我们刚才启动的容器，它的状态是 Exited （因为 <code>echo</code> 命令已经执行完毕，容器无事可做就自动退出了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps -a<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-58-11-image.png"></p><h1 id="1-Docker-架构"><a href="#1-Docker-架构" class="headerlink" title="1. Docker 架构"></a>1. Docker 架构</h1><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-22-59-59-image.png"></p><p><a href="https://docs.docker.com/get-started/overview/">Docker 文档</a>中的这张图描述了 Docker 整套应用的角色和工作流程。</p><p>Docker 是典型的 C&#x2F;S 架构（客户端&#x2F;服务端）的应用。刚才我们使用的 docker 命令实际上是客户端（Docker Client），它会与 Docker Engine 的后台服务 Docker Daemon 通信，向它发送命令。Docker 镜像存储在远端的 Docker Registry 镜像仓库中。值得一提的是，使用 docker 命令并不能直接访问镜像仓库，它只能与 Docker Daemon 通信，告诉 Daemon 自己想要做什么，然后让 Daemon 完成操作并返回结果。</p><p>简要总结一下：</p><ol><li>docker client 是命令行工具，是我们和 Docker Daemon 之间的中间人，它通过 build、pull、run、ps 等命令向 Daemon 发送请求</li><li>docker daemon 是 Docker Engine 的后台服务，负责管理容器和镜像；它和镜像仓库一同完成各种操作</li></ol><p>Docker 官方还提供了一个 hello-world 镜像，向你展示 Docker 的实际工作流程，我们只需要运行下面的命令就能查看它运行的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run hello-world<br></code></pre></td></tr></table></figure><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-01-00-image.png"></p><p>以上内容讲的大概就是说：</p><ol><li>docker 客户端与 docker daemon 通信，发送“运行 hello-world”的请求</li><li>Docker daemon 在本地镜像库找不到名为 “hello-world” 的镜像，就从 Docker Hub 镜像仓库拉取这个镜像</li><li>Docker daemon 通过 “hello-world” 镜像创建了一个容器，这个容器的输出就是你现在阅读的内容</li><li>Docker daemon 将输出传递给 docker 客户端，然后客户端将这些输出打印到终端上</li></ol><p>到这里我们探索 Docker 架构的初步了解就结束了，但还有值得一提的一些点：</p><p><strong>本地的 Docker 的客户端和 Docker daemon 如何通信？</strong></p><p>我们可以使用 <code>docker context ls</code> 命令来查看 docker 客户端在与哪个 Docker daemon 通信：</p><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-02-42-image.png"></p><p>可以看到 <code>DOCKER ENDPOINT</code> 是 <code>npipe:////./pipe/docker_engine</code> ，对于windows docker中的ENDPOINT是如何实现的，我不太了解。但是在unix系统中，ENDPOINT是一个 unix 套接字，很多时候，本机进程进行进程间通信时就使用 Unix 套接字，它本质上还是一个文件，这就是 Unix 的其中一条哲学：“一切皆文件”。</p><p><strong>什么是busybox</strong></p><p>busybox 是一个集成了三百多个最常用Linux命令和工具的软件，包含 echo、ls 等常用命令，体积很小，很适合测试任务或者嵌入式系统。</p><p><strong>为啥是 C&#x2F;S 架构</strong></p><p>C&#x2F;S架构更重要的是实现了功能分离，利于分布式应用，不限于单机，比如运行一个docker daemon，然后多个客户端都向这个服务器发命令。</p><h1 id="2-什么是容器"><a href="#2-什么是容器" class="headerlink" title="2. 什么是容器"></a>2. 什么是容器</h1><p>广义上来说：容器技术 &#x3D; 动态的容器（狭义的容器） + 静态的镜像 + 远端的仓库。接下来我们就从狭义的容器开始探究容器技术。</p><h2 id="2-1-容器：被隔离的进程"><a href="#2-1-容器：被隔离的进程" class="headerlink" title="2.1 容器：被隔离的进程"></a>2.1 容器：被隔离的进程</h2><p>容器（Container）的字面意义是集装箱，而 Docker 的字面意义是码头工人。集装箱的作用是封装各种货物使其成为一个标准的运载单位，方便统计、存储、运输…相比运送散装货物，集装箱隔离了内外环境，防止集装箱内的货物影响外界，或者被外界影响。</p><p>在计算机世界里容器也发挥着同样的作用，它将进程与环境隔离开，让进程和系统的其他部分互不影响。</p><p>我们可以尝试启动一个 CentOS的容器，并打开它的 shell 尝试运行几个命令。我的宿主机运行的是 Windows —— 也就是说，我们要在Windows操作系统上运行一个 CentOS 操作系统的容器：</p><p>我们在容器内查看系统信息，以及正在运行的进程</p><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-14-08-image.png"></p><p>而对于我们的宿主机里，显然属于不同的操作系统，在系统进程里也看不到docker中运行的进程<img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-15-24-image.png"></p><p>在容器内运行的程序完全看不到宿主机的痕迹，两个操作系统像是被“隔离”了。也就是说，<strong>容器是一个特殊的运行环境，在其中运行的进程只能访问到有限的资源和信息，无法对外界施加影响（当然不是绝对的“无法”）。</strong></p><p>容器的隔离有两层含义：</p><h3 id="运行环境隔离"><a href="#运行环境隔离" class="headerlink" title="运行环境隔离"></a>运行环境隔离</h3><p>出于对系统安全的考虑，在计算机世界我们要对进程进行“隔离”。在 Linux 操作系统中，一个不受约束的应用程序是十分危险的：他可以访问任何文件，窃取重要信息，影响正常运行的程序，甚至把系统搞瘫痪。</p><p>利用容器技术，我们可以在系统中创造出一个沙箱（sandbox），给进程一个限定的运行环境，告诉它：你只许在这个环境内自由活动，但是不允许越界。这样我们就能保障容器外系统的安全。</p><p>这样做还有一个优点就是我们能够更方便地管理应用程序的依赖项，防止在同一台机器上运行的应用程序因为依赖项冲突而无法正常工作。</p><h3 id="系统资源隔离"><a href="#系统资源隔离" class="headerlink" title="系统资源隔离"></a>系统资源隔离</h3><p>容器技术还可以为应用程序加上资源隔离。计算机里有各种各样的资源，CPU、内存、硬盘、网卡，这些资源是有限的，考虑到成本，也不允许某个应用程序无限制地占用大量系统资源。</p><p>我们可以为容器分配限定的系统资源，比如只能使用双核 CPU、2 GB 内存… 这样就可以避免进程过度消耗系统资源，让各个进程充分利用计算机硬件，同时提供稳定可靠的服务。</p><h2 id="2-2-与虚拟机的区别"><a href="#2-2-与虚拟机的区别" class="headerlink" title="2.2 与虚拟机的区别"></a>2.2 与虚拟机的区别</h2><p>容器和虚拟机都使用虚拟化技术，但它们所在的层次（也就是说隔离程度）不同，我们可以通过 Docker 文档里的这张图来了解：</p><p><img src="/shinyruotechtips/imgs/%E4%BB%8EDocker%E5%88%B0OpenShift%EF%BC%88%E4%B8%80%EF%BC%89/2022-12-17-23-20-25-image.png"></p><p>请注意，图示中容器并不运行在 Docker 之上，Docker 只是辅助建立隔离环境，让容器基于 Linux 操作系统运行</p><ol><li>容器和虚拟机的目的都是隔离资源，保证系统安全，尽量提高资源使用率</li><li>虚拟机通过 Hypervisor（虚拟机软件，KVM 等）将一台物理设备虚拟成多台逻辑设备，这些逻辑设备彼此独立，并且需要在虚拟硬件上安装操作系统才能使用；硬件虚拟化和操作系统会消耗大量的系统资源，但是它的好处就是隔离程度比较高</li><li>容器则直接利用操作系统和硬件，比虚拟机少了一层，自然会节约 CPU 和内存这些资源，比虚拟机更加轻量，对系通过资源的利用也就更加高效；当然因为多个容器共用操作系统的内核，应用程序的隔离程度就没有那么高了</li></ol><p>Ubuntu 虚拟机的启动时间可能是十几秒甚至数十秒，而一个 Ubuntu 容器只需要一秒左右便可以启动，更不用说它的镜像大小相较于完整的操作系统更小（只有70多MB），同时运行上百个容器也不在话下。</p><p>当然，这两种技术是可以同时使用的，我们可以在一台服务器上虚拟多个操作系统，然后在虚拟机中使用容器来快速运行应用程序。</p><h2 id="2-3-容器隔离的实现"><a href="#2-3-容器隔离的实现" class="headerlink" title="2.3 容器隔离的实现"></a>2.3 容器隔离的实现</h2><p>Docker 的隔离依靠 Linux 提供的三种技术 <code>namespace</code> <code>cgroup</code> <code>chroot</code> ：</p><ol><li><code>namespace</code> 用于创建独立的文件系统 主机名 进程号 还有网络等资源</li><li><code>cgroup</code> 实现对进程的 CPU、内存等资源进行配额限制</li><li><code>chroot</code> 则限制进程访问原有的文件系统，不过现在有更加现代化的 pivot_root，这里只是为了解释原理</li></ol><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>namespace 是 Linux 内核的一项功能，该功能对内核资源进行隔离，使得容器中的进程都可以在单独的命名空间中运行，并且只可以访问当前容器命名空间的资源。namespace 可以隔离进程 ID、主机名、用户 ID、文件名、网络访问和进程间通信等相关资源。</p><p>Docker 主要利用下面几种命名空间：</p><ol><li>pid namespace：用于隔离进程 ID</li><li>net namespace：网络虚拟化的基石，用于隔离网络接口，在虚拟的 net namespace 内用户可以拥有自己独立的 IP、路由、端口等</li><li>mnt namespace：文件系统挂载点隔离</li><li>ipc namespace：信号量、消息队列和共享内存的隔离</li><li>uts namespace：主机名和域名的隔离</li></ol><h3 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h3><p>Cgroups 是一个 Linux 内核功能，可以限制和隔离进程的资源使用情况（CPU、内存、磁盘 I&#x2F;O、网络等）。在容器的实现中，Cgroups 通常用来限制容器的 CPU 和内存等资源的使用。</p><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>chroot 针对正在运作的软件进程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由 chroot 设置根目录的程序，不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p><p>简单来说就是“伪造”一个文件系统来欺骗容器中的进程。用操作系统镜像文件挂载到容器进程的根目录下，变成容器的rootfs，和真实系统目录一模一样。</p><p>综合运用这三种技术，一个具备完善隔离特性的容器就出现了。</p><h2 id="2-4-镜像"><a href="#2-4-镜像" class="headerlink" title="2.4 镜像"></a>2.4 镜像</h2><p>和其他镜像一样，容器技术中的“镜像”也是只读的，它以标准格式存储了一系列的文件，然后在需要的时候再从中提取出数据运行起来。因为容器是由操作系统动态创建的，那么必然就可以用一种办法把它的初始环境给固化下来，保存成一个静态的文件，方便存放、传输、版本化管理。</p><p>镜像是容器的静态形式，它<strong>打包了应用程序的所有运行依赖项</strong>，方便保存和传输。使用容器技术运行镜像，就形成了动态的容器，由于镜像只读不可修改，所以应用程序的运行环境总是一致的。</p><p>而容器化的应用就是指以镜像的形式打包应用程序，然后在容器环境里从镜像启动容器。</p><p>之前我们运行的命令 <code>docker pull busybox</code> ，就是获取了一个打包了 busybox 应用的镜像，里面固化了 busybox 程序和它所需的完整运行环境。</p><p>而 <code>docker run busybox echo hello world</code> ，就是提取镜像里的各种信息，运用 namespace、cgroup、chroot 技术创建出隔离环境，然后再运行 busybox 的 echo 命令，输出 hello world 的字符串。</p><p>这两个步骤，由于是基于标准的 Linux 系统调用和只读的镜像文件，所以，无论是在哪种操作系统上，或者是使用哪种容器实现技术，都会<strong>得到完全一致的结果</strong>。</p><p>所谓的“容器化的应用”，或者“应用的容器化”，就是指<strong>应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行</strong>。</p><p>可以说，镜像就是静态的应用容器，容器就是动态的应用镜像，两者相互转化。</p><h3 id="镜像的内部机制"><a href="#镜像的内部机制" class="headerlink" title="镜像的内部机制"></a>镜像的内部机制</h3><p>镜像就是一个打包文件，里面包含了应用程序还有它运行所依赖的环境，例如文件系统、环境变量、配置参数等等。</p><p>容器镜像内部并不是一个平坦的结构，而是由许多的镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫“Union FS 联合文件系统”的技术把它们合并在一起，就形成了容器最终看到的文件系统。你可以用命令 docker inspect 来查看镜像的分层信息。</p><p>Docker 会检查是否有重复的层，如果本地已经存在就不会重复下载，如果层被其他镜像共享就不会删除，这样就可以节约磁盘和网络成本。</p><p>如果还想了解 UnionFS，可以参考这篇文章：<a href="https://www.cnblogs.com/bjlhx/p/13202505.html">结合docker命令理解镜像</a></p><h2 id="2-5-远端镜像仓库"><a href="#2-5-远端镜像仓库" class="headerlink" title="2.5 远端镜像仓库"></a>2.5 远端镜像仓库</h2><p>镜像仓库就非常简单了，顾名思义，它是存储镜像的地方。在构建好镜像后，开发者们通常会将镜像上传到 Registry 服务器上进行保存。这样可以保证不会因本机故障而导致镜像丢失，同时，其他开发者也能很方便地通过网络方式下载公开镜像仓库中的镜像，真正做到“开箱即用”。</p><p>总而言之，Linux世界的技术创新大多都是发源于内核，经过一层层的面向用户的抽象和封装，这就是所谓的万变不离其宗。比如传统的网络虚拟化和BGP，在容器这个新瓶子里焕发第二春，软件技术、IT行业是快速迭代的，但是维持软件系统运转的、最本质的部分并不会轻易改变。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown Syntax Guide</title>
    <link href="/shinyruotechtips/2022/12/4cf52164ac51/"/>
    <url>/shinyruotechtips/2022/12/4cf52164ac51/</url>
    
    <content type="html"><![CDATA[<p>This article offers a sample of basic Markdown syntax.</p><h1 id="Titles"><a href="#Titles" class="headerlink" title="Titles"></a>Titles</h1><p>As we started writing a markdown document, we need to add a title and some sub-headers.</p><p>Markdown supports two styles of headers, Setext and atx.</p><p>Setext-style headers are “underlined” using equal signs (for first-level headers) and dashes (for second-level headers). For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">This is an H1</span><br><span class="hljs-section">=============</span><br><br><span class="hljs-section">This is an H2</span><br><span class="hljs-section">-------------</span><br></code></pre></td></tr></table></figure><p>Any number of underlining &#x3D;’s or -’s will work.</p><p>Atx-style headers use 1-6 hash characters at the start of the line, corresponding to header levels 1-6. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># This is an H1</span><br><br><span class="hljs-section">## This is an H2</span><br><br><span class="hljs-section">###### This is an H6</span><br></code></pre></td></tr></table></figure><p>Optionally, you may “close” atx-style headers. This is purely cosmetic — you can use this if you think it looks better. The closing hashes don’t even need to match the number of hashes used to open the header. (The number of opening hashes determines the header level.) :</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># This is an H1 #</span><br><br><span class="hljs-section">## This is an H2 ##</span><br><br><span class="hljs-section">### This is an H3 ######</span><br></code></pre></td></tr></table></figure><h1 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h1><p>Tables aren’t part of the core Markdown spec, but they are part of GFM (GitHub Markdown) and Markdown Here supports them.</p><p>Here is an example of table with the output below:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Tables        </span>|<span class="hljs-string"> Are           </span>|<span class="hljs-string"> Cool  </span>|<br>|<span class="hljs-string"> ------------- </span>|<span class="hljs-string">:-------------:</span>|<span class="hljs-string"> -----:</span>|<br>|<span class="hljs-string"> col 3 is      </span>|<span class="hljs-string"> right-aligned </span>|<span class="hljs-string"> $1600 </span>|<br>|<span class="hljs-string"> col 2 is      </span>|<span class="hljs-string"> centered      </span>|<span class="hljs-string">   $12 </span>|<br>|<span class="hljs-string"> zebra stripes </span>|<span class="hljs-string"> are neat      </span>|<span class="hljs-string">    $1 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>Colons can be used to align columns.</p><p>The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown.</p><p>Example:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Markdown |<span class="hljs-string"> Less </span>|<span class="hljs-string"> Pretty</span><br><span class="hljs-string">--- </span>|<span class="hljs-string"> --- </span>|<span class="hljs-string"> ---</span><br><span class="hljs-string">*Still* </span>|<span class="hljs-string"> `renders` </span>|<span class="hljs-string"> **nicely**</span><br><span class="hljs-string">1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3</span><br></code></pre></td></tr></table></figure><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><p>Markdown supports two styles of links: inline and reference.</p><p>In both styles, the link text is delimited by [square brackets].</p><p>To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">I&#x27;m an inline-style link</span>](<span class="hljs-link">https://www.google.com</span>)<br><br>[<span class="hljs-string">I&#x27;m an inline-style link with title</span>](<span class="hljs-link">https://www.google.com &quot;Google&#x27;s Homepage&quot;</span>)<br><br>[<span class="hljs-string">I&#x27;m a reference-style link</span>][<span class="hljs-symbol">arbitrary case-insensitive reference text</span>]<br><br>[<span class="hljs-string">I&#x27;m a relative reference to a repository file</span>](<span class="hljs-link">../blob/master/LICENSE</span>)<br></code></pre></td></tr></table></figure><p>Reference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is [<span class="hljs-string">an example</span>][<span class="hljs-symbol">id</span>] reference-style link.<br></code></pre></td></tr></table></figure><p>You can optionally use a space to separate the sets of brackets:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is [an example] [id] reference-style link.<br></code></pre></td></tr></table></figure><p>Then, anywhere in the document, you define your link label like this, on a line by itself:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">id</span>]: <span class="hljs-link">http://example.com/ &quot;Optional Title Here&quot;</span><br></code></pre></td></tr></table></figure><p><strong>GitHub</strong> and <strong>GitBook</strong> supports URL autolinking. They will autolink standard URLs, so if you want to link to a URL (instead of setting link text), you can simply enter the URL and it will be turned into a link to that URL.</p><h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Inline</span><br><br>![<span class="hljs-string">Alternative text</span>](<span class="hljs-link">/path/to/img.jpg &quot;Optional title&quot;</span>)<br><br><span class="hljs-section"># Reference</span><br><br>![<span class="hljs-string">Alternative text</span>][<span class="hljs-symbol">id</span>]<br>[<span class="hljs-symbol">id</span>]: <span class="hljs-link">url/to/image &quot;Optional title&quot;</span><br></code></pre></td></tr></table></figure><p>As you may have noticed, images in Markdown are very similar to links. The difference is that:</p><ul><li>the square brackets must be prefixed with an exclamation mark and</li><li>inside they may have some alternative text. A description of the image, which is displayed if the image can’t be loaded.</li></ul><h1 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code Blocks"></a>Code Blocks</h1><p>Pre-formatted code blocks are used for writing about programming or markup source code. Rather than forming normal paragraphs, the lines of a code block are interpreted literally.</p><p>Here is an example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is a code block<br></code></pre></td></tr></table></figure><p>To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab.</p><p>For example:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This is a normal paragraph:<br><br><span class="hljs-code">    This is a code block.</span><br></code></pre></td></tr></table></figure><p>You can also create code block separated by:</p><pre><code class="hljs"><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### Inline <span class="hljs-keyword">code</span> blocks<br><br>Inline <span class="hljs-keyword">code</span> blocks can be written using: `<br><br>For example:<br><br>    This is a `<span class="hljs-keyword">inline</span> <span class="hljs-keyword">code</span> block`<br><br>### Syntax highlighting<br><br>You can define the language to be used for syntax highlighting by adding the name on the opening tag. Example:<br><br>    ```javascript<br>    var a = &#123;&#125;;<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/shinyruotechtips/2022/12/1b0dbb04ee5f/"/>
    <url>/shinyruotechtips/2022/12/1b0dbb04ee5f/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
